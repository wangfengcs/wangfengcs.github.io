{"meta":{"title":"我的博客","subtitle":"幸运的事每天都会发生","description":"life is great","author":"wangfengcs","url":"http://wangfengcs.github.io"},"pages":[{"title":"about","date":"2017-06-10T13:04:29.000Z","updated":"2017-06-10T13:04:29.547Z","comments":true,"path":"about/index.html","permalink":"http://wangfengcs.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-03-01T13:59:24.000Z","updated":"2017-06-10T14:00:06.438Z","comments":true,"path":"categories/index.html","permalink":"http://wangfengcs.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-03-01T13:02:50.000Z","updated":"2017-06-10T13:56:42.099Z","comments":true,"path":"tags/index.html","permalink":"http://wangfengcs.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"关于建模和模型评价的一些总结","slug":"关于建模和模型评价的一些总结","date":"2017-07-24T01:53:32.000Z","updated":"2017-07-24T07:18:59.598Z","comments":true,"path":"2017/07/24/关于建模和模型评价的一些总结/","link":"","permalink":"http://wangfengcs.github.io/2017/07/24/关于建模和模型评价的一些总结/","excerpt":"","text":"##模型评估方法 ###网格搜索调参 在训练集上训练模型，根据验证集上的结果调参。调好参数后，在测试集上得到测试误差。 将数据集分为训练集，验证集，测试集 将参数网格化，每一个交叉点都是一组参数 遍历每个网格参数，在训练集上训练模型，在验证集上得到与网格参数对应的验证误差 挑选最小的验证误差所对应的那个网格参数，作为最优的参数 用最优参数设置模型，在训练集?验证集上训练，得到训练误差，在测试集上得到测试误差。 因为模型参数的选择是依赖于验证集，而模型对于测试集是没有依赖的，所以在测试上的准确率一般来说会比验证集低一些。 ###交叉验证 &amp; 估计期望泛化误差 用交叉验证的目的是为了得到可靠稳定的模型。如果已经调好参了，且得到的估计的期望泛化误差比较大，那么说明模型不太适用，就可以考虑做一些特征变化或换模型了。 在非测试集上交叉验证，用MSE估计期望泛化误差，在测试集上得到测试误差 将数据集分为非测试集和测试集 在将非测试集分为k份，其中k-1份作为训练集，另一份作为验证集 在训练集上训练模型，得到一个训练误差，在验证集上测试，得到一个验证误差。 共训练了k个模型，得到k个训练误差和k个验证误差。用k个验证误差的平均来估计期望泛化误差。 在非测试集上训练模型，得到训练误差，在测试集上测试模型，得到测试误差。 为了减小因样本划分不同而引起的差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的平均。所以说，一共会训练pk个模型，并得到pk个验证误差。 如果只是为了估计模型的期望泛化误差，可以去掉验证集，并以测试集代替。 ###网格搜索 &amp; 交叉验证 比网格搜索更稳定些，因为评价的标准不再是单个的验证误差，而是k个验证误差的平均。 在非测试集上网格搜索并交叉验证，用MSE估计期望泛化误差，调参。调好参数后，在测试集上得到测试误差。 将数据集分为非测试集，测试集 将非测试集分为k份，其中k-1份作为训练集，另一份作为验证集 将参数网格化，每个交叉点都是一组参数 遍历每个网格参数，进行k交叉验证，共得到k个模型，k个训练误差，k个验证误差。用k个验证误差的平均来估计期望泛化误差，作为参数选择的评判标准。 选择估计期望泛化误差最小所对应的一个网格参数，作为最优参数 用最优参数设置模型，在非测试集上训练，得到训练误差，在测试集上得到测试误差 ###小结 对于给定的模型，确定了网络结构，确定了损失函数，确定了核的选择， 那么便确定了唯一的训练误差和测试误差，最优参数值的选择会根据网格搜索在验证集上确定。 如果模型的所有参数都确定了，那么就可以只用训练集和测试集了。 网格搜索是在验证集是调参用的。 交叉验证只是用于估计期望泛化误差。可以有验证集，也可以不用验证集。如果同时要得到训练的模型，训练误差，测试误差，那么就需要有验证集。 交叉验证可以使网格搜索的参数评判更准确。 如果不需要调参，那么就没必要有验证集了。 ##P-R曲线 &amp; ROC曲线 先列，后行 真实\\预测 正例 反例 正例 TP(True Positive) FN(False Positive) 反例 FP(False Negative) TN(True Negative) TP：正确肯定的数目；FN：漏报，没有正确找到的匹配的数目； FP：误报，给出的匹配是不正确的；TN：正确拒绝的非匹配对数； ###P-R TPR 计算列1 显示列 FPR 计算行1 显示行 $TPR=\\frac{TP}{TP+FN}$ $FPR=\\frac {FP}{FP+TN}$ ###准确率(Precision)，召回率(Recall)和F1-Score (1) 准确率(precision)：正确率 (2) 召回率(recall)：查全率 (3) F1-Score:准确率和召回率的综合指标 定义： $precision=\\frac{true positive}{true positive+false negative}=\\frac{true positive}{no.of predicted positive}$ $recall=\\frac{true positive}{true positive+false negative}=\\frac{true positive}{no.of actual positve}$ $F1-Score=2\\times\\frac{precision\\times recall}{precision+recall}$ ###正则 正则就是在训练数据的模型上加一个惩罚项，shrink模型的参数。 lasso的解是稀疏的，如sparse coding， compressed sensing ###构造目标函数 用X来构造分布，用Y来确定分布的具体值。 构造概率函数。给定x，初始超参数，构造出一个概率函数。但此概率函数的变量是y，不是x。 构造似然函数。根据真实y，得到p(y|x)概率，连乘得到似然函数 优化的参数，其实是构造分布时的超参数。 ###不平衡类 对多的类进行欠采样 对少的类进行过采样 移动阈值$\\frac{y}{1-y} \\gt \\frac{m^+}{m^-} $即为正类 少类的插值(kmeans聚类，然后在一个簇里面插值) ###生成模型 &amp; 判别模型 ####生成模型 学习的是联合分布p(y,x) 可以由联合分布p(y,x)在y上积分得到p(x)，即类条件概率p(x|y)与p(y)在y上的积分，如果p(x)的概率比较小，说明可能是异常点(outlier)，该点的分类效果可能不好。对p(x,y)在y上的积分有时比较难求，需要用MCMC抽样方法得到p(x)或变分近似p(x)。 根据贝叶斯公式，p(y,x) / p(x)得到条件分布p(y|x)，即得到预测的条件分布。 当样本量较多时，生成模型能更快地收敛于真实模型。 可以解决存在隐变量的模型，比如GMM，HMM。 需要更大的样本，做判别的时候，有些信息用不到。 ####判别模型 学习的是条件分布p(y|x)，或判别函数f(x) 需要的样本量少于生成模型 寻找的是不同类别的最优分类面 准确率一般比生成模型高 可以对原数据X进行特征的变化，例如降维，特征选择 ###Reference http://blog.csdn.net/zouxy09/article/details/8195017 https://zhengyangcs.github.io/2016/08/19/模型综述/","categories":[{"name":"工具书，机器学习","slug":"工具书，机器学习","permalink":"http://wangfengcs.github.io/categories/工具书，机器学习/"}],"tags":[{"name":"工具书，机器学习","slug":"工具书，机器学习","permalink":"http://wangfengcs.github.io/tags/工具书，机器学习/"}]},{"title":"关联规则","slug":"关联规则","date":"2017-02-10T01:19:16.000Z","updated":"2017-07-20T07:15:31.425Z","comments":true,"path":"2017/02/10/关联规则/","link":"","permalink":"http://wangfengcs.github.io/2017/02/10/关联规则/","excerpt":"","text":"关联规则 关联规则就是有关联的规则，形式可以定义为：两个 不相交 的非空集合X、Y，如果有X-&gt;Y，就说X-&gt;Y是一条关联规则。关联规则的强度由支持度(support)和自信度(confidence)来描述。 支持度的定义：$$support(X–&gt;Y) = \\frac{|X \\cap Y|}{N}$$集合X与集合Y中的项在一条记录中同时出现的次数/数据记录的个数。 自信度的定义：$$confidence(X-&gt;Y)=\\frac{|X \\cap Y|}{|X|}$$表示集合X与集合Y中的项在一条记录中同时出现的次数/集合X出现的个数。 上述所讲的支持度和自信度都是相对的支持度和自信度，不是绝对支持度，绝对支持度为：$$abs_support=N*support, N为数据记录数$$ 支持度和自信度越高，说明规则越强，关联规则挖掘就是挖掘出满足一定强度的规则。 项集：属性名称集合。比如，{a,b},{c},{a,d} 如果一个项集同时满足最小支持度阈值和最小置信度阈值，则认为这个项集的关联规则是有趣的。 频繁项集：满足最小支持度的项集。 如果一个项集{a,b}是频繁的，那么它的所有子集{a}也是频繁的。 如果一个项集{a,b}是不频繁的，那么它的所有超集{a,b,c}也是不频繁的。 Apriori是找频繁项集的算法 Apriori算法：使用候选项集找频繁项集。Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。 统计一个元素项集出现的频数，找出不小于最小支持度的项集，得到 频繁1-项集。令k=2 根据第k-1步生成的 频繁(k-1)-项集 生成 侯选k-项集，然后对数据库进行搜索，得到 侯选k-项集 的支持度，与最小支持度进行比较，从而找到 频繁k-项集，删除 侯选k-项集 中 不频繁k-项集。 如果没有 频繁k-项集 生成，则停止，返回 频繁(k-1)-项集 作为 最大频繁项集； 否则，k = k+1，返回步骤2 优点： 简单，易理解，没有复杂的理论推导 缺点： 每一步产生侯选项集时循环产生的组合过多，没有排除不应该参与组合的元素 每次计算项集的支持度时，都会对数据库的全部记录进行扫描比较，I/O开销大 采用唯一支持度，算法的适应面窄","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://wangfengcs.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wangfengcs.github.io/tags/机器学习/"}]},{"title":"Mathjax语法总结","slug":"Mathjax语法总结","date":"2017-02-04T10:32:55.000Z","updated":"2017-07-20T07:24:56.002Z","comments":true,"path":"2017/02/04/Mathjax语法总结/","link":"","permalink":"http://wangfengcs.github.io/2017/02/04/Mathjax语法总结/","excerpt":"","text":"hexo写markdown中_与*一样，表示斜体或粗体，但mathjax中_表示下标，因此： mathjax中换行\\，在markdown中写成\\\\ mathjax中下标_，在markdown改写成_ mathjax中下标{，在markdown改写成\\{ mathjax中下标}，在markdown改写成\\} 在markdown的表格中插入|，可以输入 &amp;#124; 代替 公式右键-Show Math As-Tex Commands可以查看编辑 1. 行中公式inline &amp; 独立公式displayed 行中公式 inline This is an example for $x_mu+ y_mu$. mathjax写法 This is an example for \\$x_mu+ y_mu\\$. 独立公式 displayed $$J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}$$ mathjax写法 $$J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}$$ 2. 表格 一种表格的生成方式： |col1 |col2 |col3 | |:-------|:--------|:--------| 内容行 col1 col2 col3 内容 内容 内容 3. 希腊字母 名称 大写 Tex 小写 Tex alpha $A$ A $\\alpha$ \\alpha beta $B$ B $\\beta$ \\beta gamma $\\Gamma$ \\Gamma $\\gamma$ \\gamma delta $\\Delta$ \\Delta $\\delta$ \\delta epsilon $E$ E $\\epsilon$ \\epsilon zeta $Z$ Z $\\zeta$ \\zeta eta $H$ H $\\eta$ \\eta theta $\\Theta$ \\Theta $\\theta$ \\theta iota $I$ I $\\iota$ \\iota kappa $K$ K $\\kappa$ \\kappa lambda $\\Lambda$ \\Lambda $\\lambda$ \\lambda mu $M$ M $\\mu$ \\mu nu $N$ N $\\nu$ \\nu xi $\\Xi$ \\Xi $\\xi$ \\xi omicron $O$ O $\\omicron$ \\omicron pi $\\Pi$ \\Pi $\\pi$ \\pi rho $P$ P $\\rho$ \\rho sigma $\\Sigma$ \\Sigma $\\sigma$ \\sigma tau $T$ T $\\tau$ \\tau upsilon $\\Upsilon$ \\Upsilon $\\upsilon$ \\upsilon phi $\\Phi$ \\Phi $\\phi$ \\phi chi $X$ X $\\chi$ \\chi psi $\\Psi$ \\Psi $\\psi$ \\psilon omega $\\Omega$ \\Omega $\\omega$ \\omega 运算符和数据符号 名称 显示 写法 加 $+$ + 减 $-$ - 乘 $\\times \\cdot \\ast$ \\times \\cdot \\ast 除 $\\div$ \\div 分数 $\\frac{a}{b}$或${a}\\over{b}$ \\frac{a}{b}或{a}\\over{b} 上标 $a^b$ a^b 下标 $x_y$ x_y 开二次方 $\\sqrt x$ \\sqrt x 开x次方 $\\sqrt[x]{y}$ \\sqrt[x] {y} 比较运算符 $\\lt \\gt \\leq \\geq \\neq \\approx \\equiv$ \\lt \\gt \\leq \\geq \\neq \\approx \\equiv 排列 $\\binom{n+1}{2k}$ \\binom{n+1}{2k} 小括号 $()$ () 中括号 $[]$ [] 大括号 ${}$ \\{\\} 上取整 $\\lceil\\rceil$ \\lceil \\rceil 下取整 $\\lfloor \\rfloor$ \\lfloor \\rfloor 逻辑运算符 $\\land \\lor \\lnot \\forall \\exists$ \\land \\lor \\lnot \\forall \\exists 偏导1 $\\frac{\\partial{f(x)}}{\\partial{x}}$ \\frac{\\partial{f(x)}}{\\partial{x}} 偏导2 $\\nabla_xf(x)$ \\nabla_xf(x) 集合1 $\\cup \\cap \\in$ \\cup \\cap \\in 集合2 $\\bigcup \\bigcap$ \\bigcup \\bigcap 估计 $\\hat f(x)$ \\hat f(x) 三角函数1 $sin(x)$ sin(x) 三角函数2 $arctan(x)arctan(x)$ arctan(x) 极限 $lim_{1\\rightarrow+\\infty}\\frac{1}{n(n+1)}$ lim_{1\\rightarrow+\\infty}\\frac{1}{n(n+1)} 未调整括号大小 $\\{3+\\frac{7x+5}{1+y^2}\\}$ \\{3+\\frac{7x+5}{1+y^2}\\} 调整括号大小 $\\left\\{3+\\frac{7x+5}{1+y^2}\\right\\}$ \\left\\{3+\\frac{7x+5}{1+y^2}\\right} 求和 $\\sum_1^n$ \\sum_1^n 积分1 $\\int_1^\\infty$ \\int_1^\\infty 积分2 $\\int_0^{+\\infty}x^ne^{-x}dx$ \\int_0^{+\\infty}x^ne^{-x}dx 共轭转置 $U^{\\dagger}U=UU^{\\dagger}=I$ U^{\\dagger}U=UU^{\\dagger}=I 连乘 $\\prod$ \\prod 双积分 $\\iint$ \\iint 装饰符1 $\\overline A \\underline B$ \\overline A \\underline B 装饰符2 $\\widetilde C \\widehat D$ \\widetilde C \\widehat D 装饰符3 $\\fbox E$ \\fbox E 装饰符4 $\\overleftarrow F \\underrightarrow G$ \\overleftarrow F \\underrightarrow G 装饰符5 $\\overleftrightarrow H \\underleftrightarrow I$ \\overleftrightarrow H \\underleftrightarrow I 装饰符6 $\\overbrace{(n-2)+\\underbrace{(n-1)+n}}$ \\overbrace{(n-2)+\\underbrace{(n-1)+n}} 装饰符7 $\\underbrace{a\\cdot a\\cdots a}_{b\\text{times}}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{times}} 装饰符8 $\\acute{I} \\check{J} \\grave{K}$ \\acute{I} \\check{J} \\grave{K} 字体 名称 显示 写法 注意 黑板粗体1 $\\mathbb{AaBb12} AaBb12 $ \\mathbb{AaBb12} AaBb12 黑板粗体2 $\\Bbb{AaBb12} AaBb12$ \\Bbb{AaBb12} AaBb12 好像只有大写字母有变化 黑体 $\\mathbf{AaBb12}$ \\mathbf{AaBb12} 希腊字母黑体 $\\boldsymbol{\\mu sigma} $ \\boldsymbol{\\mu sigma} 罗马字体 $\\mathrm{AaBb12} $ \\mathrm{AaBb12} 手写体 $\\mathscr{AaBb12}$ \\mathscr{AaBb12} Fraktur字体 $\\mathfrak{AaBb12}$ \\mathfrak{AaBb12} 分类表达式 $$f(x)= \\begin{cases} n=1, if\\ x\\ is\\ even\\\\ n=2, if\\ x\\ is\\ odd\\\\ n=3, if\\ x\\ is\\ 0 \\end{cases}$$ 表格 $$\\begin{array}{c|cccc} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} &amp; \\text{last}\\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 &amp; 235 \\\\ 2 &amp; 0.24 &amp; 1 &amp; 125 &amp; 235 \\\\ 3 &amp; 0.24 &amp; 1 &amp; 125 &amp; 235 \\\\ \\end{array}$$ 矩阵 $$\\begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\ 1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; a_n &amp; a_n^2 &amp; \\cdots &amp; a_n^n \\end{pmatrix}$$ 推导1 $\\begin{align}E&amp;=\\sum_{n=1}^{N}exp{-t_nf_{m-1}(\\mathbf{x_n})-\\frac12t_n\\alpha_my_m(\\mathbf{x_n})}\\\\ &amp; =\\sum_{n=1}^{N}w_n^{(m)}exp\\left\\{-\\frac12t_n\\alpha_my_m(\\mathbf{x_n})\\right\\} \\end{align}$ 推导2 $\\begin{align} \\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ &amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align}$ Reference http://blog.leanote.com/post/freewalk/Markdown-语法手册 https://zhengyangcs.github.io/2016/08/17/mathjax/ http://blog.csdn.net/wx11055/article/details/52694682","categories":[{"name":"工具书","slug":"工具书","permalink":"http://wangfengcs.github.io/categories/工具书/"}],"tags":[{"name":"工具书","slug":"工具书","permalink":"http://wangfengcs.github.io/tags/工具书/"}]},{"title":"U盘快捷方式病毒处理方法","slug":"U盘快捷方式病毒处理方法","date":"2017-01-16T11:10:37.000Z","updated":"2017-07-20T07:14:55.416Z","comments":true,"path":"2017/01/16/U盘快捷方式病毒处理方法/","link":"","permalink":"http://wangfengcs.github.io/2017/01/16/U盘快捷方式病毒处理方法/","excerpt":"","text":"当U盘文件变成快捷方式时，使用下面的代码解决: @echo off echo============================================ echo. echo U盘隐藏文件夹恢复 echo. echo============================================ pause rem echo 列出目录 dir /a:d /b &gt;yxkmp4dir.txt rem echo 列出目录外的所有文件 rem dir /a:s /a:-d /b for /f &quot;tokens=* delims= &quot; %%i in (yxkmp4dir.txt) do call :ss &quot;%%i&quot; del yxkmp4dir.txt echo. echo 全部修复完成,谢谢你的使用! echo. pause goto :eof :ss set var=%1 echo 正在修复文件夹 %var% ... attrib -s -h -r %var% goto :eof 将文件后缀改为bat,双击运行 除此之外，可以通过在文件夹选项中，选择显示全部隐藏文件，可以显示被隐藏的文件。","categories":[{"name":"工具书","slug":"工具书","permalink":"http://wangfengcs.github.io/categories/工具书/"}],"tags":[]},{"title":"Hexo简单指令","slug":"hello-world","date":"2017-01-12T14:13:00.000Z","updated":"2017-07-20T07:14:52.860Z","comments":true,"path":"2017/01/12/hello-world/","link":"","permalink":"http://wangfengcs.github.io/2017/01/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[{"name":"工具书","slug":"工具书","permalink":"http://wangfengcs.github.io/categories/工具书/"}],"tags":[{"name":"工具书","slug":"工具书","permalink":"http://wangfengcs.github.io/tags/工具书/"}]}]}